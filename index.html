
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Wallball Counter</title>
  <style>
    :root {
      --primary: #000;
      --accent: #ffcf00;
      --bg: #000;
      --font: 'Helvetica Neue', sans-serif;
    }

    body {
      margin: 0;
      font-family: var(--font);
      background: var(--bg);
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
    }

    h1 {
      font-size: 5rem;
      font-weight: 800;
      margin: 0;
      color: var(--accent);
    }

    button {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      margin: 10px 5px;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .btn-connect {
      background-color: #007bff;
      color: white;
    }

    .btn-start {
      background-color: #ffcf00;
      color: black;
    }

    .btn-calibrate {
      background-color: #28a745;
      color: white;
    }

    .counter-display {
      font-size: 4rem;
      margin: 20px 0;
    }

    
.progress-container {
  width: 90vw;
  max-width: none;
  background: #333;
  border-radius: 20px;
  overflow: hidden;
  height: 30px;
  margin-bottom: 20px;
}


    .progress-bar {
      height: 100%;
      background: var(--accent);
      width: 0%;
      transition: width 0.3s ease;
    }

    .slider-container {
      width: 100%;
      max-width: 400px;
      margin-top: 20px;
    }

    input[type=range] {
      width: 100%;
    }

    .timer {
      font-size: 3rem;
      margin-top: 10px;
    }

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.85);
      color: var(--accent);
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 3rem;
      font-weight: bold;
      z-index: 9999;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s ease;
    }

    .overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }
  </style>
</head>
<body>
  <header>
    <h1>ğŸ‹ï¸ Wallball Counter</h1>
  </header>

  <div class="counter-display">
    Treffer: <span id="count">0</span> / <span id="goalDisplay">50</span>
  </div>

  <div class="timer">â±ï¸ <span id="timer">0.0</span> s / <span id="avgTime">-</span> s pro Treffer</div>

  <div class="progress-container">
    <div class="progress-bar" id="progress"></div>
  </div>

  <div>
    <button class="btn-connect" onclick="connect()">ğŸ”— Verbinden</button>
    <button class="btn-start" onclick="startSession()">â–¶ï¸ Start / Reset</button>
    <button class="btn-calibrate" onclick="calibrate()">ğŸ§ª Kalibrieren</button>
  </div>

  <div class="slider-container">
    <label for="goalSlider">ğŸ¯ Ziel einstellen</label>
    <input type="range" id="goalSlider" min="1" max="150" value="50" oninput="updateGoal(this.value)">
  </div>

    
  <div class="overlay" id="finishOverlay" onclick="hideFinishOverlay()">ğŸ Ziel erreicht!</div>

  
<div id="status" style="margin-top: 10px; font-size: 1.2rem;">âŒ Nicht verbunden</div>

<script>
let device, server, countChar, resetChar, calibrateChar, thresholdChar;
let goalValue = 50;
let timerRunning = false;
let timerStart = 0;
let timerInterval;

async function connect() {
  try {
    device = await navigator.bluetooth.requestDevice({
      filters: [{ namePrefix: "WallballCounter" }],
      optionalServices: ['19b10000-e8f2-537e-4f6c-d104768a1214']
    });

    server = await device.gatt.connect();
    const service = await server.getPrimaryService('19b10000-e8f2-537e-4f6c-d104768a1214');

    thresholdChar = await service.getCharacteristic('19b10004-e8f2-537e-4f6c-d104768a1214');
countChar = await service.getCharacteristic('19b10001-e8f2-537e-4f6c-d104768a1214');
    resetChar = await service.getCharacteristic('19b10002-e8f2-537e-4f6c-d104768a1214');
    calibrateChar = await service.getCharacteristic('19b10003-e8f2-537e-4f6c-d104768a1214');

    countChar.startNotifications();
    countChar.addEventListener('characteristicvaluechanged', event => {
      const count = event.target.value.getUint8(0);

      if (count <= goalValue) {
        document.getElementById('count').textContent = count;
        updateProgress(count);

        if (count === 1 && !timerRunning) startTimer();
        if (count < goalValue) playHitBeep();
        if (count === goalValue) {
          stopTimer();
          playFinishBeep();
          const elapsed = (performance.now() - timerStart) / 1000;
          const avg = elapsed / goalValue;
          document.getElementById("avgTime").textContent = avg.toFixed(2);
          showFinishOverlay();
        }
      }
    });

    document.getElementById("status").textContent = "âœ… Verbunden";
    document.getElementById("status").style.color = "#28a745";
  } catch (error) {
    document.getElementById("status").textContent = "âŒ Nicht verbunden";
    document.getElementById("status").style.color = "red";
    console.error("Verbindung fehlgeschlagen:", error);
  }
}

function updateProgress(count) {
  const percent = Math.min(100, (count / goalValue) * 100);
  document.getElementById('progress').style.width = percent + '%';
}

function updateGoal(val) {
  goalValue = parseInt(val);
  document.getElementById('goalDisplay').textContent = goalValue;
  const count = parseInt(document.getElementById('count').textContent);
  updateProgress(count);
}

async function startSession() {
  if (!resetChar) return alert("Nicht verbunden.");
  await resetChar.writeValue(new Uint8Array([1]));
  document.getElementById('count').textContent = 0;
  updateProgress(0);
  resetTimer();
  document.getElementById("avgTime").textContent = "-";
  hideFinishOverlay();
}


async function calibrate() {
  if (!calibrateChar || !thresholdChar) {
    alert("âŒ Bitte zuerst verbinden.");
    return;
  }
  await calibrateChar.writeValue(new Uint8Array([1]));
  showCalibrationPopup();

  const calibElem = document.getElementById("calibrationStatus");
  if (calibElem) {
    calibElem.textContent = "ğŸ§ª Kalibrierung lÃ¤uft... (10 Sekunden)";
  }

  const logElem = document.getElementById("calibrationStatusLog");
  if (logElem) {
    logElem.innerHTML += "ğŸ•’ Kalibrierung gestartet um " + new Date().toLocaleTimeString() + "<br>";
  }

  setTimeout(() => {
    if (calibElem) calibElem.textContent = "";
    if (logElem) logElem.innerHTML += "âœ… Kalibrierung abgeschlossen<br>";
  }, 10000);
}


function startTimer() {
  timerRunning = true;
  timerStart = performance.now();
  timerInterval = setInterval(() => {
    const elapsed = (performance.now() - timerStart) / 1000;
    document.getElementById("timer").textContent = elapsed.toFixed(1);
  }, 100);
}

function stopTimer() {
  timerRunning = false;
  clearInterval(timerInterval);
}

function resetTimer() {
  stopTimer();
  document.getElementById("timer").textContent = "0.0";
}

function showFinishOverlay() {
  document.getElementById("finishOverlay").classList.add("visible");
}

function hideFinishOverlay() {
  document.getElementById("finishOverlay").classList.remove("visible");
}

function playHitBeep() {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();

  osc.type = "sine";
  osc.frequency.value = 1000;
  gain.gain.setValueAtTime(0.2, ctx.currentTime);

  osc.connect(gain);
  gain.connect(ctx.destination);

  osc.start();
  osc.stop(ctx.currentTime + 0.1); // sehr kurzer Beep

  setTimeout(() => ctx.close(), 150);
}


function playFinishBeep() {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();

  osc.type = "square";
  osc.frequency.value = 600;
  gain.gain.setValueAtTime(0.3, ctx.currentTime);

  osc.connect(gain);
  gain.connect(ctx.destination);

  osc.start();
  osc.stop(ctx.currentTime + 0.25); // kurzer Abschlusston

  setTimeout(() => ctx.close(), 300);
}


function playHitBeep() {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = "sine";
  osc.frequency.value = 1000;
  gain.gain.setValueAtTime(0.2, ctx.currentTime);
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.1);
  setTimeout(() => ctx.close(), 150);
}

function playFinishBeep() {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = "square";
  osc.frequency.value = 600;
  gain.gain.setValueAtTime(0.3, ctx.currentTime);
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.25);
  setTimeout(() => ctx.close(), 300);
}


async function showCalibrationPopup() {
  const popup = document.getElementById("calibrationPopup");
  const countdownElem = document.getElementById("calibrationCountdown");
  const resultElem = document.getElementById("calibrationResult");
  popup.classList.add("visible");
  resultElem.textContent = "";
  let seconds = 10;
  countdownElem.textContent = `ğŸ§ª Kalibrierung lÃ¤uft: ${seconds}`;
  const interval = setInterval(() => {
    seconds--;
    countdownElem.textContent = `ğŸ§ª Kalibrierung lÃ¤uft: ${seconds}`;
    if (seconds <= 0) {
      clearInterval(interval);
    }
  }, 1000);

  await new Promise(resolve => setTimeout(resolve, 10000));
  try {
    if (!thresholdChar) throw new Error("thresholdChar ist nicht verfÃ¼gbar.");
    const value = await thresholdChar.readValue();
    const threshold = value.getUint16(0, true);
    resultElem.textContent = `ğŸ“ˆ Schwellenwert: ${threshold}`;
  } catch (e) {
    resultElem.textContent = "âŒ Schwellenwert konnte nicht gelesen werden.";
    console.error("Fehler beim Lesen des neuen Schwellenwerts:", e);
  }
}

function closeCalibrationPopup() {
  const popup = document.getElementById("calibrationPopup");
  popup.classList.remove("visible");
}

</script>

<div id="calibrationPopup" class="overlay" style="display:flex; flex-direction:column; align-items:center; justify-content:center; background:#000000f2; color:#ffcf00; font-size:1.5rem; z-index:2000; text-align:center; padding:2rem;" onclick="closeCalibrationPopup()">
  <div id="calibrationCountdown">ğŸ§ª Kalibrierung lÃ¤uft: 10</div>
  <div id="calibrationResult" style="margin-top:1em;"></div>
  <div id="calibrationStatusLog" style="font-size:1rem; margin-top:1em;"></div>
  <div style="font-size:0.9rem; color:#ccc; margin-top:1em;">Klicke zum SchlieÃŸen</div>
</div>

</body>
</html>


<div id="calibrationPopup" class="overlay" style="display:flex; flex-direction:column; align-items:center; justify-content:center; background:#000000f2; color:#ffcf00; font-size:1.5rem; z-index:2000; text-align:center; padding:2rem;" onclick="closeCalibrationPopup()">
  <div id="calibrationCountdown">ğŸ§ª Kalibrierung lÃ¤uft: 10</div>
  <div id="calibrationResult" style="margin-top:1em;"></div>
  <div id="calibrationStatusLog" style="font-size:1rem; margin-top:1em;"></div>
  <div style="font-size:0.9rem; color:#ccc; margin-top:1em;">Klicke zum SchlieÃŸen</div>
</div>

</body>
</html>
